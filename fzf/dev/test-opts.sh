# shellcheck shell=bash

(return 0 2>/dev/null) && __sourced=1
[ -n "$__sourced" ] && echo >&2 "abort: this script cannot be sourced" >&2 && return 1

source debug.lib.sh
source opts.lib.sh

declare -A options_cfg
options_cfg[secret]='(
  [description]="secret option only for the ini file"
  [type]="string" 
  [init]="topsecret" 
  [modes]="f"
#  [short]="" 
#  [long]="" 
#  [arg]="" 
#  [action]="" 
#  [help]=""
)'
options_cfg[envonly]='(
  [description]="option only for env vars file"
  [type]="int" 
  [init]="" 
  [modes]="e"
#  [short]="" 
#  [long]="" 
#  [arg]="" 
#  [action]="" 
#  [help]=""
)'
# the map key is the name of the option
options_cfg[logfile]='(
  # description of the option 
  # an option without `description` is not displayed in the 
  # help string generated by `opts::generate_config_help` 
  [description]="name of the logfile"
  [type]="string" 
  [init]="/dev/null" 
  # set option from (e)nvironment and config-(f)ile
  [modes]="e,f" 
  # only options with a short or long command line flag are 
  # read from the command line
  [short]="L"   
  [long]="LOGFILE" 
  # the command line flag(s) (req)uire(s) an argument
  [arg]="req" 
  # an action function called when the command line flag is 
  # specified; if no action is specified the corresponding 
  # option will be set
#  [action]="" 
  # description of the effect/use of the command line flag
  # flags without `help` are not displayed in the 
  # help string generated by `opts::generate_flags_help`
  [help]="specify the name of the logfile"
  # name of the environment variable used to set this option
  # if `env` is not set but the mode contains `e` env is 
  # generated automatically from the option name
  [env]="CONFIG_LOGFILENAME" 
)'
options_cfg[debug]='(
  [description]="debug level"
  [modes]="f,e"
  [type]="int" 
  [init]="0" 
  [short]="D" 
  [long]="DEBUG" 
  [arg]="opt:1" 
#  [action]="" 
  [help]="specify the debug level"
)'
options_cfg[help]='(
#  [description]=""
  [type]="bool"
#  [init]=""
  [short]="h"
  [long]="help"
#  [arg]=""
  [action]="opts::usage"
  [help]="show help"
)'
options_cfg[query]='(
#  [description]=""
  [type]="string"  
#  [init]="" 
#  [short]="" 
  [long]="query" 
  [arg]="req" 
#  [action]="" 
  [help]="specify the query string"
)'

declare -A options

usage_flags="$(opts::generate_flags_help options_cfg)"
usage_config="$(opts::generate_config_help options_cfg)"

# use with reference
#declare -A option_table
#opts::parse_options_config options_cfg option_table

# or use with return value
#opts::parse_options_config options_cfg
declare -A option_table="$(opts::parse_options_config options_cfg)"

#declare -p option_table
# breakpoint

# read_config options $file
# config_from_env options

declare -A config_table="$(opts::parse_options_config_for_env options_cfg)"
declare -p config_table

# set by init file 
opts::set_options config_table options f
# set by evn var
opts::set_options config_table options e

opts::parse_options option_table options argv "$@"
echo >&2 "remainder of argv: \"$argv\""

# set default values
opts::set_options config_table options d

#declare -p options

# last thing is set default value to values not already set
#init_config options_cfg options "$@" 

declare -p options

# EOF
